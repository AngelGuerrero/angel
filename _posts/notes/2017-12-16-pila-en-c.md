---
layout: page2
title: "Pila en C++"
date: "2017-12-16 1:03:00 -0600"
note: true
categories: notas
published: true
description: Estructura de datos. Implementación de Pila en C++
---

![Pila o stack](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Pila.svg/1200px-Pila.svg.png)

Una pila es un tipo de dato abstracto que soporta dos métodos fundamentales:

- push(). Inserta un nuevo elemento en la pila.
- pop(). Quita un elemento de la pila y 'mostrarlo'.

El siguiente código es una implementación de una pila en C++.

**Archivo stack.h**

{::nomarkdown}
<pre><code class="cpp">

#pragma once
#include "Node.h"

template <class T>
class Stack
{
  int _size;

public:
  Node<T> *top;

  Stack() : top(nullptr), _size(0) {};

  ~Stack() {};

  bool push(T);
  T pop();
  T getTop();
  T *getAll();
  int getSize();
  bool isEmpty();
  bool removeAll();
};


// Push element
template <class T>
bool Stack<T>::push(T data)
{
  bool val = false;

  Node<T> *el = new Node<T>(data);

  if (isEmpty())
  {
    top = el;
  }
  else
  {
    el->next = top;
    top = el;
  }
  this->_size++;
  val = true;

  return val;
}

// Pop method
template <class T>
T Stack<T>::pop()
{
  T val = T();

  if ( ! isEmpty() )
  {
    Node<T> *el = top;

    top = top->next;
    val = el->getData();

    el->next = nullptr;
    delete el;

    this->_size--;
  }

  return val;
}

// Get elements
template <class T>
T * Stack<T>::getAll()
{
  Node<T> *iterator = top;

  static T *theArray = new T[getSize()];

  for (int i = 0; i < getSize(); i++)
  {
    theArray[i] = iterator->getData();
    iterator = iterator->next;
  }

  return theArray;
}

// Get top
template <class T>
T Stack<T>::getTop()
{
  T val = T();

  if ( ! isEmpty() )
  {
    val = top->getData();
  }

  return val;
}

// Get the this._size
template <class T>
int Stack<T>::getSize() { return this->_size; }

// check if is empty
template <class T>
bool Stack<T>::isEmpty() { return this->_size == 0; }

// Remove all elements
template <class T>
bool Stack<T>::removeAll()
{
  bool val = false;

  if ( ! isEmpty() )
  {
    while (top != nullptr)
    {
      pop();
    }

    val = true;
  }

  return val;
}
</code></pre>
{:/}



**Archivo Node.h**

{::nomarkdown}
<pre><code class="cpp">
#pragma once
template <class T>
class Node
{
  T _data;

public:
  Node<T> *next;

  Node();

  Node(T data) : _data(data),
    next(nullptr) {}

  ~Node(){};

  T getData();
  void setData(T);
};

/*
|-------------------------------------------------------------------
| Node Methods
|-------------------------------------------------------------------
|
*/
template <class T>
Node<T>::Node()
{
  this->_data = nullptr;
  this->next = nullptr;
}

template <class T>
T Node<T>::getData()
{
  return this->_data;
}

template <class T>
void Node<T>::setData(T data)
{
  this->_data = data;
}
</code></pre>
{:/}


En un ejemplo muy sencillo se podría utilizar el anterior código en mostrar un simple texto al revés.


**Archivo main.cpp**

{::nomarkdown}
<pre><code class="cpp">
#include "Stack.h"
#include <string>
#include <iostream>
using namespace std;

int main()
{
  Stack<char> stack;

  stack.push('A');
  stack.push('n');
  stack.push('g');
  stack.push('e');
  stack.push('l');

  cout << "The size of the stack: " << stack.getSize() << endl;

  while (stack.getSize() > 0)
  {
    cout << stack.pop();
  }

  cout << endl;
  system("pause");

  return 0;
}
</code></pre>
{:/}

El resultado de la ejecución del anterior código sería:

![Resultado del codigo]({{ site.url }}{{site.baseurl}}/assets/img/notes/stack_result.png)
