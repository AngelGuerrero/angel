---
title: "Cola en C++"
date: "2017-11-16 19:40:32 -0600"
description: Estructura de datos. Implementación de cola en C++
---

![Cola o fila](https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Data_Queue.svg/1200px-Data_Queue.svg.png)

Una cola o fila es una estructura de datos que está caracterízada por ser una secuencia de elementos en la que la inserción de elementos se realiza por un extremo. Esta también es llamada una estructura *FIFO* proveniente del inglés *First In First Out*.

Saber más en [Estructura de datos, colas](https://es.wikipedia.org/wiki/Cola_(inform%C3%A1tica)).

Siguiente, se puede apreciar la implementación de una fila en lenguaje C++ utilizando plantillas.

El uso de plantillas es para hacer uso de tipos de datos genéricos.

{::nomarkdown}
<pre><code class="cpp">
#pragma once
#include "Node.h"

template <class T>
class Queue
{
  Node<T> *_first;
  Node<T> *_last;
  int _size;
  T _data;

public:
  Queue() :
    _first(nullptr),
    _last(nullptr),
    _size(0),
    _data(T()) {}

  Queue(T data) :
    _data(data),
    _first(nullptr),
    _last(nullptr),
    _size(0) {}

  ~Queue() {}

  bool add(T);
  T getFirst();
  T process();
  int getSize();
  bool isEmpty();
  bool removeAll();
};


//
//  Add a new element to the queue
//
template <class T>
bool Queue<T>::add(T data)
{
  bool val = false;

  Node<T> *el = new Node<T>(data);

  if ( isEmpty() )
  {
    _first = _last = el;

    val = true;
    _size++;
  }
  else
  {
    _last->next = el;
    _last = el;

    val = true;
    _size++;
  }

  return val;
}


//
//  Get the data from the first element without delete it
//
template <class T>
T Queue<T>::getFirst()
{
  T val = T();

  if ( ! isEmpty() )
  {
    val = this->_first->getData();
  }

  return val;
}


//
//  Process an element
//  This function is like a pop(), first, get  the 'first' element
//  and then remove this element
//
template <class T>
T Queue<T>::process()
{
  T val = T();

  if (! isEmpty() )
  {
    if (this->_size == 1)
    {
      val = this->_first->getData();

      this->_first = this->_last = nullptr;

      this->_size--;
    }
    else
    {
      val = this->_first->getData();
      Node<T> *aux;

      aux = this->_first->next;
      this->_first->next = nullptr;
      this->_first = aux;
      aux = nullptr;

      delete aux;
      this->_size--;
    }
  }

  return val;
}


//
//  Remove all elements
//
template <class T>
bool Queue<T>::removeAll()
{
  bool val = false;

  if (! isEmpty() )
  {
    while (this->_first != nullptr)
    {
      process();
    }
    val = true;
  }

  return val;
}


//
//  Get the size of the queue
//
template <class T>
int  Queue<T>::getSize() { return this->_size; }


//
//  Check if is empty
//
template <class T>
bool Queue<T>::isEmpty() { return this->_size == 0; }

</code></pre>

{:/}

Para la clase *Node* se aplicaría el siguiente código.

{::nomarkdown}
<pre>
  <code class="cpp">
#pragma once
template <class T>
class Node
{
  T _data;

public:
  Node<T> *next;

  Node();

  Node(T data) : _data(data),
    next(nullptr) {}

  ~Node(){};

  T getData();
  void setData(T);
};

/*
|-------------------------------------------------------------------
| Node Methods
|-------------------------------------------------------------------
|
*/
template <class T>
Node<T>::Node()
{
  this->_data = nullptr;
  this->next = nullptr;
}

template <class T>
T Node<T>::getData()
{
  return this->_data;
}

template <class T>
void Node<T>::setData(T data)
{
  this->_data = data;
}
  </code>
</pre>

{:/}
